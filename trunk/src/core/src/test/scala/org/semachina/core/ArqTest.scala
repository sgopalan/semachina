package org.semachina.core

import org.junit._
import Assert._
import org.semachina.jena.JenaExtension._
import org.openjena.atlas.io.IndentedWriter
import com.hp.hpl.jena.query.{ResultSet, QuerySolution, Query}
import scala.collection.JavaConversions._
import org.springframework.context.annotation.AnnotationConfigApplicationContext
import org.semachina.jena.config.OWLFactory
import org.semachina.config.AppConfig
import com.weiglewilczek.slf4s.Logging
import com.hp.hpl.jena.rdf.model.{RDFNode, Resource}
import org.semachina.jena.impl.{SemachinaOntModelImpl}
import com.hp.hpl.jena.ontology.{ProfileRegistry, OntModelSpec, OntModel}
import org.semachina.jena.{SemachinaOntModel, ResultSetHandler}

/**
 * Created by IntelliJ IDEA.
 * User: sgopalan
 * Date: Aug 28, 2010
 * Time: 8:09:56 PM
 * To change this template use File | Settings | File Templates.
 */


object ArqTest {
  @BeforeClass
  def setup: Unit = {
    val ctx = new AnnotationConfigApplicationContext(classOf[AppConfig]);
  }

  @AfterClass
  def teardown: Unit = {

  }
}

/**
 * Vocabulary definitions from file:vocabularies/dublin-core_11.xml
 * @author Auto -generated by schemagen on 13 May 2003 08:51
 */

class ArqTest extends Logging {
  val NL = System.getProperty("line.separator")

  def createModel: SemachinaOntModel = {
    implicit val ontModel = new SemachinaOntModelImpl(OntModelSpec.getDefaultSpec(ProfileRegistry.OWL_DL_LANG))
    ontModel.read("http://purl.org/dc/elements/1.1/")
    val title = ontModel.getOntProperty("http://purl.org/dc/elements/1.1/title")
    val description = ontModel.getOntProperty("http://purl.org/dc/elements/1.1/description")


    ontModel.doWrite { writeModel:SemachinaOntModel =>

        val r1: Resource = writeModel.createResource("http://example.org/book#1")

        r1.addProperty(title, "SPARQL - the book")
                .addProperty(description, "A book about SPARQL")

        return writeModel
    }

    return ontModel;
  }

  @Test
  def testSparqlSelect = {
    // Create the data.
    // This wil be the background (unnamed) graph in the dataset.
    implicit val model = createModel

    // Query string.
    var query = " PREFIX dc: <http://purl.org/dc/elements/1.1/>" + NL +
            "SELECT ?title WHERE {?x dc:title ?title}";


    val closure = {
      (resultSet: ResultSet, soln: QuerySolution) =>
        assertEquals("SPARQL - the book", as[String](soln.get("title")) )
    }

    model.select(query, closure, null)

    query.toQuery.serialize(new IndentedWriter(System.out, true));
    model.close()
  }

  @Test(expected = classOf[IllegalArgumentException])
  @throws(classOf[Exception])
  def testSparqlSelectFail = {
    // Create the data.
    // This wil be the background (unnamed) graph in the dataset.
    implicit val model = createModel

    // Query string.
    var query = " PREFIX dc: <http://purl.org/dc/elements/1.1/>" + NL +
            "ASK WHERE {?x dc:title ?title}";

    try {
      model.select(query, null, Map.empty[String, RDFNode])
    }
    catch {
      case e: Exception => {
        logger.error(e.getMessage, e)
        throw e
      }
    }
    finally {
      model.close()
    }
  }

  @Test
  def testSparqlAsk = {
    // Create the data.
    // This wil be the background (unnamed) graph in the dataset.
    implicit val model = createModel

    // Query string.
    var query = " PREFIX dc: <http://purl.org/dc/elements/1.1/>" + NL +
            "ASK WHERE {?x dc:title ?title}"

    assertTrue(model.ask(query, null))

    model.close
  }

  @Test(expected = classOf[IllegalArgumentException])
  @throws(classOf[Exception])
  def testSparqlAskFail() = {
    // Create the data.
    // This wil be the background (unnamed) graph in the dataset.
    implicit val model = createModel

    // Query string.
    var query = " PREFIX dc: <http://purl.org/dc/elements/1.1/>" + NL +
            "SELECT ?title WHERE {?x dc:title ?title}"

    try {
      assertFalse(model.ask(query, null))
    }
    catch {
      case e: Exception => {
        logger.error(e.getMessage, e)
        throw e
      }
    }
    finally {
      model.close
    }
  }


  @Test
  def testSparqlLARQ = {
    // Create the data.
    // This wil be the background (unnamed) graph in the dataset.
    implicit val model = createModel

    // Query string.
    var query: String =
    "PREFIX xsd: <http://www.w3.org/2001/XMLSchema#> " +
            "PREFIX :    <http://example/> " +
            "PREFIX pf:  <http://jena.hpl.hp.com/ARQ/property#> " +
            "SELECT * { ?lit pf:TextMatch 'SPARQL'. }"

    query.toQuery.serialize(new IndentedWriter(System.out, true));

    val closure = {
      (resultSet: ResultSet, soln: QuerySolution) =>
        var str = ""
        var varnames = resultSet.getResultVars.toList
        varnames.foreach {name :String => str + name + ": " + soln.getLiteral(name) + ", " }
        println(str)
    }

    model.select(query, closure, null)
    model.close
  }
}