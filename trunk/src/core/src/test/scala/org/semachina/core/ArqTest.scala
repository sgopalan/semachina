package org.semachina.core

import org.junit._
import Assert._
import org.semachina.jena.JenaExtension._
import com.hp.hpl.jena.ontology.OntModel
import org.openjena.atlas.io.IndentedWriter
import com.hp.hpl.jena.rdf.model.{Resource}
import com.hp.hpl.jena.query.{ResultSet, QuerySolution, Query}
import scala.collection.JavaConversions._
import org.springframework.context.annotation.AnnotationConfigApplicationContext
import org.semachina.jena.core.OWLFactory
import org.semachina.config.AppConfig
import com.weiglewilczek.slf4s.Logging

/**
 * Created by IntelliJ IDEA.
 * User: sgopalan
 * Date: Aug 28, 2010
 * Time: 8:09:56 PM
 * To change this template use File | Settings | File Templates.
 */


object ArqTest {
  @BeforeClass
  def setup: Unit = {
    val ctx = new AnnotationConfigApplicationContext(classOf[AppConfig]);
  }

  @AfterClass
  def teardown: Unit = {

  }
}

/**
 * Vocabulary definitions from file:vocabularies/dublin-core_11.xml
 * @author Auto -generated by schemagen on 13 May 2003 08:51
 */

class ArqTest extends Logging {
  val NL = System.getProperty("line.separator")

  def createModel: OntModel = {
    val ontModel = OWLFactory.createOntologyModel
    ontModel.read("http://purl.org/dc/elements/1.1/")
    val title = ontModel.getOntProperty("http://purl.org/dc/elements/1.1/title")
    val description = ontModel.getOntProperty("http://purl.org/dc/elements/1.1/description")


    ontModel -> {
      it =>
        val r1: Resource = it.createResource("http://example.org/book#1")

        r1.addProperty(title, "SPARQL - the book")
                .addProperty(description, "A book about SPARQL")
    }

    return ontModel;
  }

  @Test
  def testSparqlSelect = {
    // Create the data.
    // This wil be the background (unnamed) graph in the dataset.
    implicit val model = createModel

    // Query string.
    var query: Query = " PREFIX dc: <http://purl.org/dc/elements/1.1/>" + NL +
            "SELECT ?title WHERE {?x dc:title ?title}";

    val closure = {
      (resultSet: ResultSet, soln: QuerySolution) =>
        assertEquals("SPARQL - the book", soln.getLiteral("title")())
    }

    model.select(query, closure)

    query.serialize(new IndentedWriter(System.out, true));
    model.close()
  }

  @Test(expected = classOf[IllegalArgumentException])
  @throws(classOf[Exception])
  def testSparqlSelectFail = {
    // Create the data.
    // This wil be the background (unnamed) graph in the dataset.
    implicit val model = createModel

    // Query string.
    var query: Query = " PREFIX dc: <http://purl.org/dc/elements/1.1/>" + NL +
            "ASK WHERE {?x dc:title ?title}";

    try {
      model.select(query, null)
    }
    catch {
      case e: Exception => {
        logger.error(e.getMessage, e)
        throw e
      }
    }
    finally {
      model.close()
    }
  }

  @Test
  def testSparqlAsk = {
    // Create the data.
    // This wil be the background (unnamed) graph in the dataset.
    implicit val model = createModel

    // Query string.
    var query: Query = " PREFIX dc: <http://purl.org/dc/elements/1.1/>" + NL +
            "ASK WHERE {?x dc:title ?title}";

    assertTrue(model.ask(query))

    model.close
  }

  @Test(expected = classOf[IllegalArgumentException])
  @throws(classOf[Exception])
  def testSparqlAskFail() = {
    // Create the data.
    // This wil be the background (unnamed) graph in the dataset.
    implicit val model = createModel

    // Query string.
    var query: Query = " PREFIX dc: <http://purl.org/dc/elements/1.1/>" + NL +
            "SELECT ?title WHERE {?x dc:title ?title}";

    try {
      assertFalse(model.ask(query))
    }
    catch {
      case e: Exception => {
        logger.error(e.getMessage, e)
        throw e
      }
    }
    finally {
      model.close
    }
  }


  @Test
  def testSparqlLARQ = {
    // Create the data.
    // This wil be the background (unnamed) graph in the dataset.
    implicit val model = createModel

    // Query string.
    var query: String =
    "PREFIX xsd: <http://www.w3.org/2001/XMLSchema#> " +
            "PREFIX :    <http://example/> " +
            "PREFIX pf:  <http://jena.hpl.hp.com/ARQ/property#> " +
            "SELECT * { ?lit pf:textMatch 'SPARQL'. }"

    query.serialize(new IndentedWriter(System.out, true));

    val closure = {
      (resultSet: ResultSet, soln: QuerySolution) =>
        var str = ""
        var varnames = resultSet.getResultVars.toList
        varnames.foreach(name => str += name + ": " + soln.get(name) + ", ")
        println(str)
    }

    model.select(query, closure)
    model.close
  }
}